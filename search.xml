<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloud 配置 eureka-server （sprinboot2.0.1环境）]]></title>
    <url>%2F2018%2F06%2F05%2FSpringCloud%20%E9%85%8D%E7%BD%AE%20eureka-server%20%EF%BC%88sprinboot2.0.1%E7%8E%AF%E5%A2%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringCloud 配置 eureka-server （sprinboot2.0.1环境）1.Maven导入包&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 其中 这部分代码很关键 在按SpringCloud微服务实战中 那样去配置项目在springboot2.0以上版本跑不起来需要添加下面的代码 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 2.在启动类加上注解@EnableEurekaServer@EnableEurekaServer @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 3.在application.properties添加以下代码 server.port = 1111 eureka.instance.hostname = localhost eureka.client.register-with-eureka=false eureka.client.fetch-registry = false eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/ server.port = 1111 代表访问端口 eureka.client.register-with-eureka=false 代表不注册自己 eureka.client.fetch-registry = false 注册中心不去检索服务 eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/ 访问地址 3.在启动springboot在浏览器中输入http://localhost:1111/ 就可以访问 4.备注博主踩了大半天的坑最终通过这个方法实现了希望能帮到一些初学者]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat8配置管理员]]></title>
    <url>%2F2018%2F06%2F05%2Ftomcat8%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98%2F</url>
    <content type="text"><![CDATA[tomcat8配置管理员配置（1）要使用localhost:8080/manager 需要配置/home/tomcat/apache-tomcat-8.5.29/conftomcat_user.xml在12&lt;tomcat-users&gt;&lt;/tomcat-users&gt; 标签中添加12345678&lt;role rolename=&quot;manager&quot;/&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;admin&quot;/&gt; &lt;role rolename=&quot;admin-gui&quot;/&gt; &lt;role rolename=&quot;manager-script&quot;/&gt; &lt;role rolename=&quot;manager-jmx&quot;/&gt; &lt;role rolename=&quot;manager-status&quot;/&gt; &lt;user username=&quot;admin&quot; password=&quot;password&quot; roles=&quot;admin-gui,admin,manager-gui,manager,manager-script,manager-jmx,manager-status&quot;/&gt; 之后重启点击Manager App 还是会报错 （2）在tomat_home/conf/Catalina/localhost/下 添加manager.xml 配置远程访问manager： 在tomat_home/conf/Catalina/localhost/下 添加manager.xml 1234&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot; docBase=&quot;$&#123;catalina.home&#125;/webapps/manager&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt; &lt;/Context&gt; （3）之后点击Manager App 输入 账号密码： admin password ,进入到管理界面在下面有一个选择文件，选择你要部署的war之后，按deploy之后稍等一会，等文件上传完成后，就会部署成功，整个过程不用重启tomcat。 （4）取消部署当部署之后，由于一些原因你不想部署，可以在对应的部署应用后面 按undeploy，tomcat就会自动删除weapps目录下war和解压后的文件。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centors tomcat启动慢解决方法]]></title>
    <url>%2F2018%2F06%2F05%2FCentors-tomcat%E5%90%AF%E5%8A%A8%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Centors tomcat启动慢解决方法原因Tomcat 7/8都使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这里花去了342秒，也即接近6分钟。SHA1PRNG算法是基于SHA-1算法实现且保密性较强的伪随机数生成器。在SHA1PRNG中，有一个种子产生器，它根据配置执行各种操作。 （1）如果java.security.egd属性或securerandom.source属性指定的是”file:/dev/random”或”file:/dev/urandom”，那么JVM会使用本地种子产生器NativeSeedGenerator，它会调用super()方法，即调用SeedGenerator.URLSeedGenerator(/dev/random)方法进行初始化。 （2）如果java.security.egd属性或securerandom.source属性指定的是其它已存在的URL，那么会调用SeedGenerator.URLSeedGenerator(url)方法进行初始化。 这就是为什么我们设置值为”file:///dev/urandom”或者值为”file:/./dev/random”都会起作用的原因。 在这个实现中，产生器会评估熵池（entropy pool）中的噪声数量。随机数是从熵池中进行创建的。当读操作时，/dev/random设备会只返回熵池中噪声的随机字节。/dev/random非常适合那些需要非常高质量随机性的场景，比如一次性的支付或生成密钥的场景。 当熵池为空时，来自/dev/random的读操作将被阻塞，直到熵池收集到足够的环境噪声数据。这么做的目的是成为一个密码安全的伪随机数发生器，熵池要有尽可能大的输出。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做。 那么什么是环境噪声？ 随机数产生器会手机来自设备驱动器和其它源的环境噪声数据，并放入熵池中。产生器会评估熵池中的噪声数据的数量。当熵池为空时，这个噪声数据的收集是比较花时间的。这就意味着，Tomcat在生产环境中使用熵池时，会被阻塞较长的时间。 解决方法：（1）在Tomcat环境中解决 可以通过配置JRE使用非阻塞的Entropy Source。 在catalina.sh中加入这么一行： -Djava.security.egd=file:/dev/./urandom 即可。 加入后再启动Tomcat，整个启动耗时下降到Server startup in 2912 ms。 （2）在JVM环境中解决 打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容： securerandom.source=file:/dev/random 改成 securerandom.source=file:/dev/./urandom 然后你会发现tomact启动速度起飞]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(点对点)]]></title>
    <url>%2F2018%2F05%2F18%2FActiveMQ(%E7%82%B9%E5%AF%B9%E7%82%B9)%2F</url>
    <content type="text"><![CDATA[#ActiveMQ介绍&emsp;&emsp;ActiveMQ是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。ActiveMQ使用Apache提供的授权，任何人都可以对其实现代码进行修改。ActiveMQ官网 ##ActiveMQ(一) ###点对点消息发布的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package Activemq;import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.MessageProducer;import javax.jms.Session;import javax.jms.TextMessage;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;/** * 消息生产者 * @author Administrator * */public class JMSProducer &#123; private static final String USERNAME=ActiveMQConnection.DEFAULT_USER; // 默认的连接用户名 private static final String PASSWORD=ActiveMQConnection.DEFAULT_PASSWORD; // 默认的连接密码 private static final String BROKEURL=ActiveMQConnection.DEFAULT_BROKER_URL; // 默认的连接地址 private static final int SENDNUM=10; // 发送的消息数量 public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话 接受或者发送消息的线程 Destination destination; // 消息的目的地 MessageProducer messageProducer; // 消息生产者 // 实例化连接工厂 connectionFactory=new ActiveMQConnectionFactory(JMSProducer.USERNAME, JMSProducer.PASSWORD, JMSProducer.BROKEURL); try &#123; connection=connectionFactory.createConnection(); // 通过连接工厂获取连接 connection.start(); // 启动连接 session=connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); // 创建Session destination=session.createQueue(&quot;FirstQueue1&quot;); // 创建消息队列 messageProducer=session.createProducer(destination); // 创建消息生产者 sendMessage(session, messageProducer); // 发送消息 session.commit(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally&#123; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 发送消息 * @param session * @param messageProducer * @throws Exception */ public static void sendMessage(Session session,MessageProducer messageProducer)throws Exception&#123; for(int i=0;i&lt;JMSProducer.SENDNUM;i++)&#123; TextMessage message=session.createTextMessage(&quot;ActiveMQ 发送的消息&quot;+i); System.out.println(&quot;发送消息：&quot;+&quot;ActiveMQ 发送的消息&quot;+i); messageProducer.send(message); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package Activemq;import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.MessageConsumer;import javax.jms.Session;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory; /** * 消息消费者 * @author Administrator * */public class JMSConsumer2 &#123; private static final String USERNAME=ActiveMQConnection.DEFAULT_USER; // 默认的连接用户名 private static final String PASSWORD=ActiveMQConnection.DEFAULT_PASSWORD; // 默认的连接密码 private static final String BROKEURL=ActiveMQConnection.DEFAULT_BROKER_URL; // 默认的连接地址 public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话 接受或者发送消息的线程 Destination destination; // 消息的目的地 MessageConsumer messageConsumer; // 消息的消费者 // 实例化连接工厂 connectionFactory=new ActiveMQConnectionFactory(JMSConsumer2.USERNAME, JMSConsumer2.PASSWORD, JMSConsumer2.BROKEURL); try &#123; connection=connectionFactory.createConnection(); // 通过连接工厂获取连接 connection.start(); // 启动连接 session=connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); // 创建Session destination=session.createQueue(&quot;FirstQueue1&quot;); // 创建连接的消息队列 messageConsumer=session.createConsumer(destination); // 创建消息消费者 messageConsumer.setMessageListener(new Listener()); // 注册消息监听 &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627package Activemq;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 消息监听 * @author Administrator * */public class Listener implements MessageListener&#123; @Override public void onMessage(Message message) &#123; // TODO Auto-generated method stub try &#123; System.out.println(&quot;收到的消息：&quot;+((TextMessage)message).getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 备注:&emsp;&emsp;先打开运行\bin\win64\activemq.bat（如果机器为32位就打开32位的文件夹）然后在浏览器输入：http://127.0.0.1:8161/admin/index.jsp默认账号密码为：admin]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(一对多)]]></title>
    <url>%2F2018%2F05%2F18%2FActiveMQ(%E4%B8%80%E5%AF%B9%E5%A4%9A)%20%2F</url>
    <content type="text"><![CDATA[#ActiveMQ介绍&emsp;&emsp;ActiveMQ是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。ActiveMQ使用Apache提供的授权，任何人都可以对其实现代码进行修改。ActiveMQ官网 ##ActiveMQ(一) ###点对点消息发布的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package Activemq2;import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.MessageProducer;import javax.jms.Session;import javax.jms.TextMessage;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;/** * 消息生产者-消息发布者 * @author Administrator * */public class JMSProducer &#123; private static final String USERNAME=ActiveMQConnection.DEFAULT_USER; // 默认的连接用户名 private static final String PASSWORD=ActiveMQConnection.DEFAULT_PASSWORD; // 默认的连接密码 private static final String BROKEURL=ActiveMQConnection.DEFAULT_BROKER_URL; // 默认的连接地址 private static final int SENDNUM=10; // 发送的消息数量 public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话 接受或者发送消息的线程 Destination destination; // 消息的目的地 MessageProducer messageProducer; // 消息生产者 // 实例化连接工厂 connectionFactory=new ActiveMQConnectionFactory(JMSProducer.USERNAME, JMSProducer.PASSWORD, JMSProducer.BROKEURL); try &#123; connection=connectionFactory.createConnection(); // 通过连接工厂获取连接 connection.start(); // 启动连接 session=connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); // 创建Session // destination=session.createQueue(&quot;FirstQueue1&quot;); // 创建消息队列 destination=session.createTopic(&quot;FirstTopic1&quot;); messageProducer=session.createProducer(destination); // 创建消息生产者 sendMessage(session, messageProducer); // 发送消息 session.commit(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally&#123; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 发送消息 * @param session * @param messageProducer * @throws Exception */ public static void sendMessage(Session session,MessageProducer messageProducer)throws Exception&#123; for(int i=0;i&lt;JMSProducer.SENDNUM;i++)&#123; TextMessage message=session.createTextMessage(&quot;ActiveMQ 发送的消息&quot;+i); System.out.println(&quot;发送消息：&quot;+&quot;ActiveMQ 发布的消息&quot;+i); messageProducer.send(message); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Activemq2;import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.MessageConsumer;import javax.jms.Session;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;/** * 消息消费者-消息订阅者一 * @author Administrator * */public class JMSConsumer &#123; private static final String USERNAME=ActiveMQConnection.DEFAULT_USER; // 默认的连接用户名 private static final String PASSWORD=ActiveMQConnection.DEFAULT_PASSWORD; // 默认的连接密码 private static final String BROKEURL=ActiveMQConnection.DEFAULT_BROKER_URL; // 默认的连接地址 public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话 接受或者发送消息的线程 Destination destination; // 消息的目的地 MessageConsumer messageConsumer; // 消息的消费者 // 实例化连接工厂 connectionFactory=new ActiveMQConnectionFactory(JMSConsumer.USERNAME, JMSConsumer.PASSWORD, JMSConsumer.BROKEURL); try &#123; connection=connectionFactory.createConnection(); // 通过连接工厂获取连接 connection.start(); // 启动连接 session=connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); // 创建Session // destination=session.createQueue(&quot;FirstQueue1&quot;); // 创建连接的消息队列 destination=session.createTopic(&quot;FirstTopic1&quot;); messageConsumer=session.createConsumer(destination); // 创建消息消费者 messageConsumer.setMessageListener(new Listener()); // 注册消息监听 &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package Activemq2;import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.MessageConsumer;import javax.jms.Session;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;/** * 消息消费者-消息订阅者二 * @author Administrator * */public class JMSConsumer2 &#123; private static final String USERNAME=ActiveMQConnection.DEFAULT_USER; // 默认的连接用户名 private static final String PASSWORD=ActiveMQConnection.DEFAULT_PASSWORD; // 默认的连接密码 private static final String BROKEURL=ActiveMQConnection.DEFAULT_BROKER_URL; // 默认的连接地址 public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话 接受或者发送消息的线程 Destination destination; // 消息的目的地 MessageConsumer messageConsumer; // 消息的消费者 // 实例化连接工厂 connectionFactory=new ActiveMQConnectionFactory(JMSConsumer2.USERNAME, JMSConsumer2.PASSWORD, JMSConsumer2.BROKEURL); try &#123; connection=connectionFactory.createConnection(); // 通过连接工厂获取连接 connection.start(); // 启动连接 session=connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); // 创建Session // destination=session.createQueue(&quot;FirstQueue1&quot;); // 创建连接的消息队列 destination=session.createTopic(&quot;FirstTopic1&quot;); messageConsumer=session.createConsumer(destination); // 创建消息消费者 messageConsumer.setMessageListener(new Listener2()); // 注册消息监听 &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526package Activemq2;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 消息监听-订阅者一 * @author Administrator * */public class Listener implements MessageListener&#123; @Override public void onMessage(Message message) &#123; // TODO Auto-generated method stub try &#123; System.out.println(&quot;订阅者一收到的消息：&quot;+((TextMessage)message).getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526package Activemq2;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 消息监听-订阅者二 * @author Administrator * */public class Listener2 implements MessageListener&#123; @Override public void onMessage(Message message) &#123; // TODO Auto-generated method stub try &#123; System.out.println(&quot;订阅者二收到的消息：&quot;+((TextMessage)message).getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 备注:&emsp;&emsp;实现订阅消息的推送，一定是先开启消费者，所以程序运行的顺序是先开启两个消费者，然后在默认网站：http://127.0.0.1:8161/admin/index.jsp可以看到两个消费者，然后发送消息，分别可以在消费者的两个控制台看到输出。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 安装java+msql+tomcat]]></title>
    <url>%2F2018%2F05%2F05%2Flinux-%E5%AE%89%E8%A3%85java-msql-tomcat%2F</url>
    <content type="text"><![CDATA[linux 安装java+msql+tomcat环境的搭建&emsp;&emsp;1.阿里云购买服务器阿里云（学生经过实名认证之后能购买9.9包月的ESC服务器）&emsp;&emsp;2.在安全组配置添加端口号(vsftp:21,ssh:22,tomcat:80,mysql:3306,1024-65535)(这一步很重要没在安全组添加的话下面所以的安装都会连接不上。博主也踩了好几次坑)&emsp;&emsp;3.安装vsftp服务教程&emsp;&emsp;4.安装jre教程&emsp;&emsp;5.安装mysql教程&emsp;&emsp;6.安装Tomcat教程 备注： &emsp;&emsp;1.博主使用的是阿里云ESC Centors7服务器，亲测有效。 &emsp;&emsp;2.在linux添加端口时如果出现firewall is not running 因为没有开启防火墙的原因，输入命令systemctl start firewalld，没有任何提示就说明防火墙开启成功。 &emsp;&emsp;3.环境搭建成功后记得给作者点鼓励。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next+GithubPage 搭建博客]]></title>
    <url>%2F2018%2F05%2F04%2FHexo-Next-GithubPage-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo+Next+GithubPage 搭建博客搭建方法:网站上有很多建站的方法：&emsp;&emsp;1.Hexo + GitHub Pages&emsp;&emsp;2.Jekyll + GitHub Pages&emsp;&emsp;3.WordPress + 服务器 + 域名&emsp;&emsp;4.DeDeCMS + 服务器 + 域名 Hexo + GitHub Pages 建站的优点&emsp;&emsp;1.GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间&emsp;&emsp;2.通过 Hexo 你可以轻松地使用 Markdown 编写文章，简单方便。 博客的搭建: 基础教程(大概需要20分钟，完成博客的基础模块，出自白小明大佬) 进阶教程(大概需要几个小时，扩展博客的功能，出自代码咖啡大佬) 自由搭配教程(出自Juli距离大佬) 备注:&emsp;&emsp;1.进阶教程中的评论系统出问题推荐使用畅言&emsp;&emsp;2.进阶教程中的搜索功能添加出现问题的话，可以采用另一种方法教程(出自Zetao Yang大佬)]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld 之 佛祖保佑 永无BUG]]></title>
    <url>%2F2018%2F05%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[HelloWorld 之 佛祖保佑 永无BUG/* _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\ = /O ____/`---&apos;\____ .&apos; \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / / ======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG */ 备注:&emsp;&emsp;1.更多图请移步至图库]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
</search>
